---
title: "Using the BESTMPA package"
author: "Remi Daigle"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, cache=FALSE, include=FALSE}
library(knitr)
opts_chunk$set(fig.width=11, fig.height=11)

```
Basic description of BESTMPA...

## Housekeeping
Before getting started, using the housekeeping function will prepare the environment and your file structure for modelling. This function will conveniently create a results folder, clear the environment, figures, delete previous results, and increase the memory limit if desired.

```{r load packages and housekeeping}
require(BESTMPA)
require(rgdal)
require(rgeos)
require(raster)
require(igraph)
require(ggplot2)
require(tidyverse)
require(data.table)

opts_chunk$set(fig.width=7, fig.height=7)

results_folder <- "D:/BESTMPA_results"
housekeeping(results_folder=results_folder,env=TRUE,fig=TRUE,delete=TRUE,memorylimit=memory.limit())

```

## Spatial Baselayer
### Exclusive Economic Zone
```{r load eez}
EEZ <- readOGR(dsn=paste0(getwd(),"/shapefiles"),layer="eez_iho_union_v2")
plot(EEZ, col='blue')
```

Remove Canadian part of the Davis Strait for EEZ since it's beyond cod's normal habitat
```{r trim eez}
plot(EEZ, col='blue')
EEZ <- EEZ[EEZ$marregion!="Canadian part of the Davis Strait",]
plot(EEZ, col='red',add=T)
```

### Load cod habitat and breeding sites
Shapefile generated by georeferencing figure 2 from Lough 2004
```{r load Habitats and Breeding}
Habitats <- readOGR(dsn=paste0(getwd(),"/shapefiles"),layer="cod_habitat")
plot(Habitats,col='green')
Breeding <- readOGR(dsn=paste0(getwd(),"/shapefiles"),layer="cod_breeding")[2:15,] # remove first Breeding zone, outside EEZ
plot(Breeding,col='yellow',add=T)

```

### Establish basic grid
Define `cell_size` in m, minimum size of MPA's in number of `cells`, default projection and which areas to include in the grid's dataframe
```{r initiate grid}
# cell size in m
cell_size <- 20000

# minimum size of MPA
cells=3

# default projection
proj  <- "+proj=utm +zone=20 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"

# create grid
p <- initgrid(EEZ,cell_size,proj,areas=c(Habitats=Habitats,Breeding=Breeding))

plot(p)
plot(p[p$Habitats==1,],col='green',add=T)
plot(p[p$Breeding==1,],col='yellow',add=T)

```

### Create protection scenarios
Define basic parameters for protection scenarios:
```{r define protection parameters}
# load existing MPAS
oldMPA <- readOGR(dsn=paste0(getwd(),"/shapefiles"),layer="MPAs_mar")
oldMPA <- spTransform(oldMPA,CRS(proj))

#remove those smaller than cell size
oldMPA <- oldMPA[gArea(oldMPA,byid = TRUE)>=cell_size^2,]

oldMPA <- apply(gCovers(oldMPA,p,byid = TRUE),1,any)|apply(gOverlaps(oldMPA,p,byid = TRUE),1,any)

# number of replicates
replicates <- 1:50

# target protection level in proportion (e.g. 0.2 is 20% protection)
MPA_coverage <- 0.10

# fixed distance for setting MPA distance in km in fixed distance scenario
fixdist <- 75000
```


This is how the four scenarios were created. This portion of code is a little time consuming; therefore, I write the grid to file.
```{r}
# ```{r create new scenarios, eval=FALSE, include=FALSE}
#### set status-quo scenario ####
p <- addscenario(domain=p,included=oldMPA,replicates=replicates,name="Status_quo",cells=cells)

# #### set maximum distance ####
# p <- addscenario(domain=p,included=oldMPA,MPA_coverage=MPA_coverage,replicates=replicates,name="MPA_MD",cell_size=cell_size,cells=cells)
# 
# #### set fixed distance ####
# p <- addscenario(domain=p,included=oldMPA,MPA_coverage=MPA_coverage,replicates=replicates,dist=fixdist,name="MPA_FX",cell_size=cell_size,cells=cells)

#### set targeted scenario ####
p <- addscenario(domain=p,included=oldMPA,priority=p$Habitats,excluded=p$Breeding,MPA_coverage=MPA_coverage,replicates=replicates,dist=fixdist,name="MPA_TR",cell_size=cell_size,cells=cells)

writeOGR(p,dsn="shapefiles",layer="master_polygon",driver="ESRI Shapefile",overwrite_layer = TRUE)
```

Instead, I load default grid file that was saved to file to save time.
```{r load scenario}
p <- readOGR(dsn="shapefiles",layer="master_polygon")
```

# Looping for time and scenarios
##Define variable to be used in the loops.
### Define time
```{r Define time}
# total model run time in years (e.g. 2001:2100 would be 100 years)
time <- 2021:2071
spinup <- 20 # number of years before "time" the model starts, results from spin-up years are not saved, all scenarios start as status quo
tot_time <- (min(time)-spinup):max(time)
```

### Define fish growth and reproduction
```{r Define fish growth and reproduction}
# Von Bertalanffy growth model parameters (Knickle and Rose 2013)
# Lt = Linf * {1-exp(-k*(t-t0))}, where Lt is length (cm) at age t (year), Linf is the asymptotic length (cm), k is the VB growth coefficient (1/year), and t0 is the x intercept (year). Linf = 112.03 (95% CI = 10.46). k = 0.13 (95% CI = 0.021). t0 = 0.18).
Linf_mean <- 112.03
Linf_SD <- 10.46/1.96
k_mean <- 0.13
k_SD <- 0.021/1.96
t0 <- 0.18

# calculate new weight - Length-weight relationship (Knickle and Rose 2013) fish$weight <- l_to_w_int * fish$length^l_to_w_power
l_to_w_int  <- 0.000011
l_to_w_power <- 2.91

# minimum age at maturity logistic equation
age_mat_steepness <- 2.5
age_mat_sigmoid <- 4


# Fecundity (size dependent). 0.5 million eggs per kg of female
fecundity <- 0.5*10^6

# Maximum age considered in matrix
maxage <- 20

# calculate which breeding area is closest to each grid cell
breeding_near <- apply(gDistance(spTransform(Breeding,proj),p,byid = T),1,which.min)


```

### Define sources of natural mortality
```{r Define sources of natural mortality}
# natural mortality (Swain & Chouinard 2008)
M <- rnorm(10000,0.5938,0.0517)
M <- M[M<=1&M>=0] # eliminate any possible values of M >1 or M <0

# larval mortality (Mountain et al. 2008)
lM <- rbeta(10000,1000,1.2) #larval mortality of 99.88% (range 98.98-99.99%)
#hist(lM);mean(lM);min(lM);max(lM)

# Beverton-Holt model for carrying capacity based recruitment mortality, carrying capacity is the mean of North American carrying capacities in Table 3 of Myers et al. 2001 (mean of log CC=-1.202222222 tonnes/km^2 SD=0.9199018667)

# Habitat carrying capacity, in kg of virtual fish per cell (4779 is the number of cells in the default grid). This could be substituted with "known" habitat carrying capacity.
CCs <- (10^rnorm(10000,-1.202222222,0.9199018667))*(cell_size^2)/1000
CCs <- CCs[CCs>0][1:4779] #enforce no negative CCs
# adjust CCs to be 0 outside habitat
CCs <- CCs*p$Habitats

```

### Define dispersal
```{r Define dispersal}
# larval dispersal kernels are assumed to be exponential, e_fold_larvae is the e folding scale in km (the distance at which there will be fewer settlers by a factor of e). We assume that scale to be sqrt of 2cm/s*90d (avg current velocity * PLD) because we assume that the current is like a random walk
e_fold_larvae <- 2/100000*60*60*24*90*1000

# adult dispersal kernels are also assumed to be exponential, e_fold_adult (in km) was calculated from data in Lawson & Rose 2000
e_fold_adult  <- sqrt(74.139*1000)
# minimium age for adult migration (minimum size is 50 cm) Lawson & Rose 2000
min_age_migration <- which.min(abs(age2length(1:maxage)-50))

# generate connectivity matrix
#adult
cma <- initcm(p,e_fold_adult,cell_size)
#larvae
cml <- initcm(p,e_fold_larvae,cell_size)
```

### Define fisherman behaviour and management
```{r Define fisherman behaviour and management}
# specify spatial distribution of fish_licenses for shore distance calculation in effort calculation
# can be spatial points or spatial polygons data frame (sp package)
fish_communities <- getData('GADM', country="CAN", level=1) # provinces
fish_communities <- fish_communities[fish_communities$NAME_1=="New Brunswick"|
                                         fish_communities$NAME_1=="Newfoundland and Labrador"|
                                         fish_communities$NAME_1=="Nova Scotia"|
                                         fish_communities$NAME_1=="Prince Edward Island"|
                                         fish_communities$ID_1==11,]    # this means Quebec, the accent make bad things happen when formatting
# fish_communities <- getBigPolys(gSimplify(fish_communities,tol=0.05,topologyPreserve = T))
fish_communities <-gSimplify(fish_communities,tol=0.05,topologyPreserve = T)

plot(fish_communities)

# number of licenses per region in fish_communities
fish_licenses <- c(866, 4714, 3002, 879, 963)

# fisheries mortality at Maximum Sustainable Yield (Mountain et al. 2008)
FMSY <- 0.28

# quota set to fraction of FMSY as per precautionary principle
FMSY_buffer <- 2/3

# number of years to use in biomass estimate
biomass_est_n_years <- 5

# minimium age caught by nets (minimum size is 38 cm) Feekings et al. 2013
min_age_catch <- which.min(abs(age2length(1:maxage)-38))

# calculate distances from shore
distance <- gDistance(spTransform(fish_communities,proj),p,byid = T)

# list scenarios for looping
scenarios <- names(p)[grep("MPA_",names(p))] # assumes all scenarios begin with "MPA_"
scenarios <- scenarios[order(as.numeric(substr(scenarios,8,nchar(scenarios))))]

```

## Loop over scenario and time
```{r Loop over scenario and time}
# ```{r Loop over scenario and time, eval=FALSE, include=FALSE}

pb <- progressBar("Looping through scenarios and time", "scenario",0, 1, 0)
for(s in scenarios){
    for(y in tot_time){
        gc() # keeps memory from getting clogged
        setProgressBar(pb, (which(s==scenarios)-1)/length(scenarios)+(1/length(scenarios)*((y-min(tot_time))/length(tot_time))), label=paste("Calculating scenario:",s,"year:",y))
        
        #### initiate `fish` or recruit the `recruits` ####
        if(y==min(tot_time)){
            fish <- initpop(initial_abun=250*10^6,cells=length(p),maxage=maxage,rate=0.7)
            biomass_est_bank <- NULL
        } else {
            fish[,1+1:maxage] <- fish[,1:maxage]
            fish[,1] <- recruits
        }
        
        # check for extinctions
        if(any(fish<0)) fish[fish<0] <- 0
        
        #### adult dispersal ####
        fish <- dispersal(fish,cm=cma,ages=min_age_migration:maxage)
        
        #### adult mortality ####
        fish <- mortality(fish,M=sample(M,nrow(fish)),ages=1:maxage)
        
        # fish outside the habitat die automatically
        fish <- fish*p$Habitats
        
        #### reproduction ####
        # generate eggs
        recruits <- fish2eggs(fish,fecundity=fecundity,age_mat_steepness=age_mat_steepness,age_mat_sigmoid=age_mat_sigmoid,l_to_w_int=l_to_w_int,l_to_w_power=l_to_w_power,Linf_mean=Linf_mean,Linf_SD=Linf_SD,k_mean=k_mean,k_SD=k_SD,t0=t0)
        
        # relocate eggs to nearest breeding ground
        recruits <- data.frame(r=recruits,b=breeding_near,polys=p$Breeding*breeding_near!=0) %>%
            group_by(b) %>%
            summarize(rec=sum(r),poly=sum(polys)) %>%
            mutate(recruits=rec/poly) %>%
            ungroup() %>%
            roundprob()
        recruits <- (left_join(data.frame(b=breeding_near),recruits,by="b")*p$Breeding) %>%
            dplyr::select(recruits) %>%
            unlist() %>%
            matrix()
        
        
        #### larval dispersal ####
        recruits <- dispersal(recruits,cm=cml,ages=0)
        
        recruits <- mortality(recruits,M=sample(lM,length(recruits)),ages=0)
        
        # density dependent recruitment
        recruits <- roundprob(recruits/(1+rowSums(fish)/CCs))
        recruits[is.nan(recruits)] <- 0
        
        # fishing
        ages=min_age_catch:maxage
        
        biomass <- sum(apply(fish,1,function(x) sum(length2weight(age2length(0:maxage))*x)))
        
        biomass_est_bank <- c(rnorm(1,biomass,biomass*0.2),biomass_est_bank)
        
        if(length(biomass_est_bank)>biomass_est_n_years) biomass_est_bank <- biomass_est_bank[1:biomass_est_n_years]
        x <- 1:length(biomass_est_bank)
        
        quota <- suppressWarnings(as.numeric(predict(lm(biomass_est_bank ~ x), data.frame(x = length(biomass_est_bank)+1))))*FMSY*FMSY_buffer

        if(!y %in% time) fishcatch <- fishing(fish,quota,ages,distance,fish_licenses,mpa=p$MPA_SQ_1)
        if(y %in% time) fishcatch <- fishing(fish,quota,ages,distance,fish_licenses,mpa=p[[s]])
        
        
        catch <- Reduce("+",fishcatch)
        fish <- fish-catch
        kg <- t(do.call(rbind,lapply(fishcatch,fish2weight,ages)))
        names(kg) <- names(fish_communities)
        
        # writing to disk

        if(y %in% time) write.csv(fish,paste0(results_folder,"/fish_",s,"_",y,".csv"))
        if(y %in% time) write.csv(fishcatch,paste0(results_folder,"/fishcatch_",s,"_",y,".csv"))
        if(y %in% time) write.csv(kg,paste0(results_folder,"/kg_",s,"_",y,".csv"))
    }
}

close(pb)

```

### Define cost evaluation
```{r Define cost evaluation}
########################################### cost evaluation ##############################################
# normal operating cost ($) per fisherman from (Department of Fisheries and Oceans, 2007, Table A.19 Mixed Fishery Fleet)
# labour (CAD $46587) and fuel ($9008) vary with distance, the remainder does not
fish_operating_cost_ratio <- (46587+9008)/105054 # (labour+fuel)/total
# default profitability to calibrate operating cost (Department of Fisheries and Oceans, 2007, Table A.19 and 5.7 Mixed Fishery Fleet)
Status_quo_profitability <- 166184/105054 #$ catch value/$ operating expense

# landed value for cod CAD/kg (http://www.dfo-mpo.gc.ca/stats/commercial/sea-maritimes-eng.htm)
fish_landed_value <- 1.24

# Social discount rates (choose 3)
SDR <- c(0.015,0.03,0.06)


```

```{r Plotting}
# load fish catches
filenames <- list.files(results_folder,pattern="kg_")
# filenames <- filenames[c(grep('SQ',filenames),grep('TR',filenames))]
fileinfo <- substr(filenames,8,nchar(filenames)-4)

catch <- lapply(paste0(results_folder,'/',filenames), fread, col.names=c("cell",paste("community_",names(fish_communities)))) %>%
    setNames(fileinfo) %>%
    rbindlist(use.names=TRUE,idcol=TRUE) %>%
    separate(col=.id,into=c("scenario","replicate","year")) %>%
    gather(community,kg,starts_with("community_")) %>%
    ungroup()


catch$grossvalue <- catch$kg*fish_landed_value

catch$distancekm <- as.vector(distance)/1000

catch_summary <- catch %>%
    group_by(scenario,replicate,year) %>%
    summarise(distanceGV=weighted.mean(distancekm,grossvalue),
              grossvalue=sum(grossvalue)) %>%
    ungroup()

catch_summary$distanceGV[is.nan(catch_summary$distanceGV)] <- 0

SQinitialstats <- catch_summary %>%
    filter(scenario=="SQ",year==min(time)) %>%
    summarize(distanceGV=mean(distanceGV,na.rm=T),
              grossvalue=mean(grossvalue,na.rm=T))

fleetfixedcost <- SQinitialstats$grossvalue/Status_quo_profitability*(1-fish_operating_cost_ratio)
fleetvariablecost <- SQinitialstats$grossvalue/Status_quo_profitability*fish_operating_cost_ratio/SQinitialstats$distanceGV

catch_summary$netvalue <- catch_summary$grossvalue-fleetfixedcost-(fleetvariablecost*catch_summary$distanceGV)
catch_summary$cumsum <- do.call(c, tapply(catch_summary$netvalue,
                                          paste0(catch_summary$scenario, catch_summary$replicate),
                                          FUN=cumsum))



ggplot(catch_summary,aes(x=as.numeric(year),y=grossvalue,colour=scenario))+
    geom_point(cex=2)+geom_smooth()+
    theme_classic()

ggplot(catch_summary,aes(x=as.numeric(year),y=cumsum,colour=scenario))+
    # geom_point(cex=2)+
    geom_smooth()+
    theme_classic()+
    scale_colour_manual(values=c("yellow","blue"))

# ggplot(catch_summary,aes(x=as.numeric(year),y=distanceGV,colour=scenario))+
#     geom_point(cex=2)+geom_smooth()+
#     theme_classic()
```



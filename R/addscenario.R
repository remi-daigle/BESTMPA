#' Title
#'
#' @param domain the gridded model domain (SpatialPolygonsDataFrame) as generated by inigrid
#' @param priority a logical vector indicating which grid cells are to be prioritized when assigning MPA protection. The algorithm will select all
#' @param excluded
#' @param MPA_coverage
#' @param replicates
#' @param dist
#' @param name
#' @param cell_size
#' @param cells
#' @param included
#'
#' @return
#' @export
#'
#' @examples
addscenario <- function(domain,included=NA,priority=NA,excluded=NA,MPA_coverage=0.1,replicates=25,dist=NA,name="MPA_SQ",cell_size,cells){

    if(name=="MPA_SQ"){

        for(i in replicates){
            domain[[paste0(name,"_",i)]] <- included
        }

        return(domain)

    } else {
        # create neighbours and graphs

        require(igraph)
        require(spdep)

        nb <- poly2nb(domain,snap=100)
        gr <- spdf2graph(domain,nb)

        # dist from m to cells
        if(!is.na(dist)) dist <- round(dist/cell_size)+1


        # loop through replicates

        for(i in replicates){
            print(paste("calculating",name, "replicate",i))

            # set status_quo as MPAs
            domain[[paste0(name,"_",i)]] <- included

            # generate new MPA sizes
            MPA_sizes <- generatempasizes(cell_size,cells,domain,MPA_coverage,included)

            # set distances
            if(is.na(dist)) dist <- round(sqrt(length(domain))/(sqrt(length(MPA_sizes))-1))


            # plot(domain)
            prioritize <- TRUE
            for(j in MPA_sizes){
                candidates <- NULL
                tol <- 1

                while(length(candidates)<1){

                    candidates <- unique(unlist(neighborhood(gr,order=dist,node=which(domain@data[,names(domain)==paste0(name,"_",i)]))))

                    # remove non-priority and excluded
                    if(!any(is.na(priority))&prioritize) candidates <- candidates[priority[candidates]]
                    if(!any(is.na(excluded))) candidates <- candidates[!excluded[candidates]]

                    candidates <- candidates[!candidates %in% unlist(neighborhood(gr,order=dist*tol,node=which(domain@data[,names(domain)==paste0(name,"_",i)])))]

                    tol <- tol*0.9
                }

                seed <- sample(candidates,1)
                while(length(seed)<j){
                    seed <- unique(c(seed,sample(unlist(nb[seed]))))
                    # # remove non-priority and excluded
                    if(!any(is.na(priority))&prioritize) seed <- seed[priority[seed]]
                    if(!any(is.na(excluded))) seed <- seed[!excluded[seed]]
                }

                if(length(seed)>j) seed <- seed[1:j]
                # plot(domain[seed,],col='blue',add=T)
                domain[[paste0(name,"_",i)]][seed] <- TRUE
                if(sum(domain[[paste0(name,"_",i)]])>=sum(priority,na.rm=T)) prioritize <- FALSE

            }

        }
        return(domain)

    }

}
